# 3.无重复字符的最长子串

给定一个字符串s，请你找出其中不含有重复字符的 **最长子串** 的长度。

## 题解

### 滑动窗口

涉及子串，可以用滑动窗口



### 动态规划+哈希表

$dp[i]$: 以当前 $i$ 为终止位置的无重复最长子串长度，

$map$：记录一个字符的最后出现位置

- 如果$dp[i-1]$存在此字符，用$map$找到上一次位置$j$，$dp[i]$ 就是上一次出现的 $j$ +1到 $i$ 的长度：$i-j$

- 如果$dp[i-1]$不存在此字符，$dp[i]=dp[i-1]+1$

- 怎么看以$i-1$结尾的字符串是否包含$s[i]$呢？ 
  - 用$dp[i-1]$ 和 $i-j$ 比较大小

因此 状态转移方程：
$$
dp[i]=
\begin {cases} dp[i-1]+1, &  dp[i-1]\lt i-j \\ 
i-j, & dp[i-1]\ge i-j
\end{cases}
$$


```java
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        // 考虑字符串为空
        if(n==0) return 0;

        int dp[] = new int[n];
        int res = 1;
        dp[0]=1;
        Map<Character,Integer> hashmap = new HashMap<>();
        hashmap.put(s.charAt(0),0);
        for(int i=1;i<n;i++){
            int j = hashmap.getOrDefault(s.charAt(i),-1);
            hashmap.put(s.charAt(i),i);
            if(dp[i-1]<i-j){
                dp[i]=dp[i-1]+1;
            }else {
                dp[i]=i-j;
            }
            res = Math.max(dp[i],res);
        }

        return res;
    }
```

#### 优化：

只牵扯到前一个的状态，只需要记录上一个的状态，可以用一个变量来代替数组。

这样也不用将第一个单独处理。

~~~java
    public int lengthOfLongestSubstring(String s) { 
        int res = 0;
        int tmp=0;
        Map<Character,Integer> hashmap = new HashMap<>();
       
        for(int i=0;i<s.length();i++){
            int j = hashmap.getOrDefault(s.charAt(i),-1);
            hashmap.put(s.charAt(i),i);
            if(tmp<i-j){
                tmp+=1;
            }else {
                tmp=i-j;
            }
            res = Math.max(tmp,res);
        }

        return res;
    }
~~~

